W1:
Zookeeper 分布式服务框架是Apache Hadoop 的一个子项目，它主要是用来解决分布式应用中经常遇到的一些数据管理问题，
如：统一命名服务、状态同步服务、集群管理、分布式应用配置项、分布式锁的管理等。

文件系统：zk维护一个类文件系统，包含一系列的目录项，每个目录项称为znode。包括持久结点，持久顺序结点，临时结点，临时顺序结点。
        一个znode可以包含一些子znode，和关联的数据。

注册机制：客户端注册监听它关心的目录节点，当目录节点发生变化（数据改变、被删除、子目录节点增加删除）时，zookeeper会通知客户端。

leader：选举产生
follower: 可以接收请求，参与选举
observer: 只能接收请求

特性：
    1.最终一致性：client不论连接到哪个Server，展示给它都是同一个视图。

    2.可靠性：具有简单、健壮、良好的性能，如果消息m被一台服务器接受，那么它将被所有的服务器接受。

    3.实时性：Zookeeper保证客户端将在一个时间间隔范围内获得服务器的更新信息，或者服务器失效的信息。
            但由于网络延时等原因，Zookeeper不能保证两个客户端能同时得到刚更新的数据，如果需要最新数据，应该在读数据之前调用sync()接口。

    4.等待无关（wait-free）：慢的或者失效的client不得干预快速的client的请求，使得每个client都能有效的等待。

    5.原子性：更新只能成功或者失败，没有中间状态。

    6.顺序性：包括全局有序和偏序两种：全局有序是指如果在一台服务器上消息a在消息b前发布，则在所有Server上消息a都将在消息b前被发布；
            偏序是指如果一个消息b在消息a后被同一个发送者发布，a必将排在b前面。


原子广播(ZAB):
    原则：在一个分布式数据库系统中，如果各节点的初始状态一致，
        每个节点都执行相同的操作序列，那么他们最后能得到一个一致的状态。

    myid:集群内每个服务器唯一的标识ID。

    zxid:高32位是Leader的epoch，从1开始，每次选出新的Leader，epoch加一。
        低32位为该epoch内的序号，每次epoch变化，都将低32位的序号重置。这样保证了zkid的全局递增性。

状态同步:
    客户端向Leader发起写请求
    Leader将写请求以Proposal的形式发给所有Follower并等待ACK
    Follower收到Leader的Proposal后返回ACK
    Leader得到过半数的ACK（Leader对自己默认有一个ACK）后向所有的Follower和Observer发送Commmit
    Leader将处理结果返回给客户端

    Follower/Observer均可接受写请求，但不能直接处理，而需要将写请求转发给Leader处理

    Leader/Follower/Observer都可直接处理读请求，从本地内存中读取数据并返回给客户端即可。

leader选举:   https://baijiahao.baidu.com/s?id=1693897375037977921&wfr=spider&for=pc
    zxid：zk通过事务id(zxid)来表示数据的新旧，一个节点zxid越大则该节点的数据越新。
            所以Zookeeper选举时会根据zxid的大小来作为投票的基本规则。
    改票：一个节点在开始进行选举时，首先认为自己的数据是最新的，会先投自己一票，并
        且把这张选票发送给其他服务器，这张选票里包含了两个重要信息：zxid和sid，sid表示这张选票投的服务器id，
        zxid表示这张选票投的服务器上最大的事务id，同时也会接收到其他服务器的选票，接收到其他服务器的选票后，
        可以根据选票信息中的zxid来与自己当前所投的服务器上的最大zxid来进行比较，如果其他服务器的选票中的zxid较大，
        则表示自己当前所投的机器数据没有接收到的选票所投的服务器上的数据新，所以本节点需要改票，改成投给和刚刚接收到的选票一样。
    投票箱：在每个节点内存里利用一个数组来作为投票箱。每个节点里都有一个投票箱，
        节点会将自己的选票以及从其他服务器接收到的选票放在这个投票箱中。因为集群节点是相互交互的，
        并且选票的PK规则是一致的，所以每个节点里的这个投票箱所存储的选票都会是一样的，这样也可以达到公用一个投票箱的目的。
    领导者：每个节点开始进行领导选举后，会不断的接收其他节点的选票，然后进行选票PK，将自己的选票修改为投给数据最新的节点，
        这样就保证了，每个节点自己的选票代表的都是自己暂时所认为的数据最新的节点，再因为其他服务器的选票都会存储在投票箱内，
        所以可以根据投票箱里去统计是否有超过一半的选票和自己选择的是同一个节点，都认为这个节点的数据最新，
        一旦整个集群里超过一半的节点都认为某一个节点上的数据最新，则该节点就是领导者。